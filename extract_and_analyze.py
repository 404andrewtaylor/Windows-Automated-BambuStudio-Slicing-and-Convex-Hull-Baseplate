#!/usr/bin/env python3
"""
Gcode Extraction and First Layer Analysis

This script takes a .gcode.3mf file and:
1. Extracts gcode using ReplaceBaseplate methods
2. Analyzes the first layer of the gcode
3. Computes a convex hull that encompasses the first layer
"""

import os
import sys
import tempfile
import shutil
import re
import subprocess
import numpy as np
from scipy.spatial import ConvexHull
import matplotlib.pyplot as plt
from pathlib import Path
import argparse


def extract_gcode_from_3mf(input_3mf, output_gcode):
    """Extract G-code from a 3MF file using Python's zipfile module."""
    
    import zipfile
    
    with tempfile.TemporaryDirectory() as temp_dir:
        temp_path = Path(temp_dir)
        
        # Extract the 3MF file using zipfile
        with zipfile.ZipFile(input_3mf, 'r') as zip_ref:
            zip_ref.extractall(temp_path)
        
        # Find the G-code file
        gcode_file = temp_path / "Metadata" / "plate_1.gcode"
        if not gcode_file.exists():
            raise Exception("Could not find plate_1.gcode in the 3MF file")
        
        # Copy the G-code to output location
        shutil.copy2(gcode_file, output_gcode)


def find_gcode_3mf_file(stl_path):
    """Find the .gcode.3mf file generated by Bambu Studio."""
    stl_dir = os.path.dirname(stl_path)
    stl_name = os.path.splitext(os.path.basename(stl_path))[0]
    
    # Look for .gcode.3mf file in the same directory as the STL
    potential_gcode_3mf = os.path.join(stl_dir, f"{stl_name}.gcode.3mf")
    
    if os.path.exists(potential_gcode_3mf):
        print(f"[FILE] Found G-code 3MF file: {potential_gcode_3mf}")
        return potential_gcode_3mf
    
    # If not found, search for any .gcode.3mf files in the directory
    for file in os.listdir(stl_dir):
        if file.endswith('.gcode.3mf'):
            found_gcode_3mf = os.path.join(stl_dir, file)
            print(f"[FILE] Found G-code 3MF file: {found_gcode_3mf}")
            return found_gcode_3mf
    
    raise FileNotFoundError(f"No .gcode.3mf file found in {stl_dir}")


def extract_gcode_from_3mf_file(three_mf_path):
    """Extract gcode from the .gcode.3mf file."""
    print(f"[PACKAGE] Extracting gcode from: {three_mf_path}")
    
    with tempfile.NamedTemporaryFile(suffix='.gcode', delete=False) as temp_gcode:
        temp_gcode_path = temp_gcode.name
    
    try:
        # Use the extraction method from ReplaceBaseplate
        extract_gcode_from_3mf(three_mf_path, temp_gcode_path)
        
        # Read the extracted gcode
        with open(temp_gcode_path, 'r') as f:
            gcode_content = f.read()
        
        print("[OK] Gcode extracted successfully")
        return gcode_content
        
    finally:
        # Clean up temp file
        if os.path.exists(temp_gcode_path):
            os.unlink(temp_gcode_path)


# ------------------------------
# Utilities: parse G1 move tokens (from your code)
# ------------------------------
move_token_re = re.compile(r'([XYZEFS])([-+]?[0-9]*\.?[0-9]+)')

def parse_move(line):
    """Return dict with X,Y,Z,E,F (floats) found in a move line. Returns None if not a motion-like line."""
    if not line.strip().startswith(("G0", "G1")):
        return None
    tokens = dict()
    for m in move_token_re.finditer(line):
        tokens[m.group(1)] = float(m.group(2))
    return tokens

def find_layers_ranges(lines):
    """Return dict layer_index -> (start_line_idx, end_line_idx_exclusive)."""
    layer_lines = {}
    current_layer = None
    for i, ln in enumerate(lines):
        if ln.startswith("; layer num/total_layer_count:"):
            try:
                # Extract layer number from format: "; layer num/total_layer_count: 1/795"
                parts = ln.split(':')[1].strip().split('/')
                current_layer = int(parts[0].strip())
                layer_lines[current_layer] = [i, None]
            except:
                pass
    # fill end indices
    sorted_layers = sorted(layer_lines.items(), key=lambda x: x[0])
    keys = [k for k,_ in sorted_layers]
    for idx, k in enumerate(keys):
        start = layer_lines[k][0]
        if idx+1 < len(keys):
            next_start = layer_lines[keys[idx+1]][0]
            layer_lines[k][1] = next_start
        else:
            layer_lines[k][1] = len(lines)
    # convert values to tuples
    return {k:(v[0], v[1]) for k,v in layer_lines.items()}

def collect_extrusion_points(lines, start, end):
    """Return list of (x,y) for all moves with extrusion E increments in region."""
    pts = []
    # we need to track previous E to decide whether move extrudes
    prevE = None
    prevXY = None
    for i in range(start, end):
        line = lines[i]
        m = parse_move(line)
        if m:
            x = m.get('X', None)
            y = m.get('Y', None)
            e = m.get('E', None)
            if e is not None:
                # absolute E: if prevE is not None and e > prevE + tiny -> extrusion
                if prevE is None:
                    prevE = e
                    if x is not None and y is not None:
                        prevXY = (x,y)
                    continue
                if e > prevE + 1e-8:
                    # extrusion occurred: use current XY if present, else prevXY
                    if x is None or y is None:
                        if prevXY is not None:
                            pts.append(prevXY)
                    else:
                        pts.append((x,y))
                        prevXY = (x,y)
                prevE = e
            else:
                # no E in this move; but might be travel
                if x is not None and y is not None:
                    prevXY = (x,y)
    return pts

def find_first_layer_by_z(lines):
    """Find first layer by looking for Z movements - fallback method."""
    first_z = None
    first_layer_start = 0
    first_layer_end = len(lines)
    
    for i, line in enumerate(lines):
        m = parse_move(line)
        if m and 'Z' in m:
            z_val = m['Z']
            if first_z is None:
                first_z = z_val
                first_layer_start = i
                print(f"[ANALYSIS] Found first layer at Z={z_val}, starting at line {i}")
            elif abs(z_val - first_z) > 0.1:  # Significant Z change indicates new layer
                first_layer_end = i
                print(f"[ANALYSIS] First layer ends at line {i} (Z changed from {first_z} to {z_val})")
                break
    
    return first_layer_start, first_layer_end

def parse_gcode_first_layer(gcode_content):
    """Parse the gcode and extract first layer coordinates using your improved method."""
    print("[SEARCH] Analyzing first layer...")
    
    lines = gcode_content.split('\n')
    
    # Try to find layer ranges using your method first
    layer_ranges = find_layers_ranges(lines)
    
    if layer_ranges:
        # Get the first layer
        first_layer_idx = min(layer_ranges.keys())
        first_layer_start, first_layer_end = layer_ranges[first_layer_idx]
        print(f"[ANALYSIS] Found first layer {first_layer_idx} at lines {first_layer_start}-{first_layer_end}")
    else:
        # Fallback: find first layer by Z movements
        print("[WARNING]  No ;LAYER: comments found, using Z-based layer detection...")
        first_layer_start, first_layer_end = find_first_layer_by_z(lines)
    
    # Collect extrusion points using your method
    pts = collect_extrusion_points(lines, first_layer_start, first_layer_end)
    
    # If no extrusion points, fallback to any XY moves
    if not pts:
        print("[WARNING]  No extrusion points found, trying fallback...")
        for i in range(first_layer_start, first_layer_end):
            m = parse_move(lines[i])
            if m and 'X' in m and 'Y' in m:
                pts.append((m['X'], m['Y']))
    
    if not pts:
        raise ValueError("No XY points found in first layer")
    
    print(f"[ANALYSIS] Found {len(pts)} points in first layer")
    return np.array(pts)


# ------------------------------
# Convex hull (Monotone chain) - from your code
# ------------------------------
def convex_hull(points):
    """Returns list of points in hull (ccw) or [] if insufficient."""
    pts = sorted(set(points))
    if len(pts) <= 1:
        return pts
    def cross(o, a, b):
        return (a[0]-o[0])*(b[1]-o[1]) - (a[1]-o[1])*(b[0]-o[0])
    lower = []
    for p in pts:
        while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:
            lower.pop()
        lower.append(p)
    upper = []
    for p in reversed(pts):
        while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:
            upper.pop()
        upper.append(p)
    hull = lower[:-1] + upper[:-1]
    return hull

def compute_convex_hull(points):
    """Compute the convex hull of the first layer points using your algorithm."""
    print("[HULL] Computing convex hull...")
    
    # Convert numpy array to list of tuples for your algorithm
    point_list = [(p[0], p[1]) for p in points]
    
    hull_points = convex_hull(point_list)
    
    if len(hull_points) < 3:
        # Degenerate hull: expand single point to small square
        if len(hull_points) == 1:
            x, y = hull_points[0]
            hull_points = [(x-0.5, y-0.5), (x+0.5, y-0.5), (x+0.5, y+0.5), (x-0.5, y+0.5)]
        else:
            raise ValueError("Need at least 3 points to compute convex hull")
    
    print(f"[OK] Convex hull computed with {len(hull_points)} vertices")
    return None, np.array(hull_points)  # Return None for hull object, just the points


def offset_hull(hull_points, buffer_mm=2.0):
    """
    Apply buffer/offset to convex hull by scaling it up from its center.
    Ensures the edge of the scaled hull is at least buffer_mm away from the original edge.
    
    Algorithm:
    1. Calculate the center of the hull
    2. Find the minimum distance from center to any vertex (closest point)
    3. Scale all points outward from center by a factor that ensures at least buffer_mm distance
    4. This guarantees at least buffer_mm minimum distance everywhere
    
    Args:
        hull_points: numpy array of (x, y) points forming convex hull
        buffer_mm: Minimum buffer distance in mm (default: 2.0)
    
    Returns:
        numpy array of buffered hull points
    
    Raises:
        ValueError: If buffer operation fails or produces invalid geometry
    """
    # Validate input
    if len(hull_points) < 3:
        raise ValueError(f"Need at least 3 points for hull, got {len(hull_points)}")
    
    # Ensure hull_points is a numpy array
    hull_points = np.array(hull_points, dtype=np.float64)
    
    # Calculate the center of the hull (centroid)
    center = np.mean(hull_points, axis=0)
    
    # Calculate distance from center to each vertex
    distances_from_center = np.array([np.linalg.norm(point - center) for point in hull_points])
    
    # Find the minimum distance (closest point to center)
    min_distance = np.min(distances_from_center)
    
    if min_distance < 1e-10:
        # Degenerate case: all points at center
        raise ValueError("Hull is degenerate (all points at center)")
    
    # Calculate scale factor to ensure at least buffer_mm distance
    # If the closest point is at distance d from center, we need to scale it to (d + buffer_mm)
    # Scale factor = (d + buffer_mm) / d = 1 + buffer_mm / d
    scale_factor = 1.0 + (buffer_mm / min_distance)
    
    # Scale all points outward from center
    # For each point: new_point = center + (point - center) * scale_factor
    buffered_points = center + (hull_points - center) * scale_factor
    
    # Validate output
    if len(buffered_points) < 3:
        raise ValueError(f"Buffered hull has insufficient points: {len(buffered_points)}")
    
    return buffered_points


def visualize_results(points, hull_points, output_dir):
    """Create a visualization of the first layer and its convex hull."""
    print("[ANALYSIS] Creating visualization...")
    
    plt.figure(figsize=(12, 8))
    
    # Plot all first layer points
    plt.scatter(points[:, 0], points[:, 1], alpha=0.6, s=1, color='blue', label='First layer points')
    
    # Plot convex hull
    hull_points_closed = np.vstack([hull_points, hull_points[0]])  # Close the hull
    plt.plot(hull_points_closed[:, 0], hull_points_closed[:, 1], 'r-', linewidth=2, label='Convex hull')
    
    # Plot hull vertices
    plt.scatter(hull_points[:, 0], hull_points[:, 1], color='red', s=50, label='Hull vertices')
    
    plt.xlabel('X (mm)')
    plt.ylabel('Y (mm)')
    plt.title('First Layer Analysis - Convex Hull')
    plt.legend()
    plt.grid(True, alpha=0.3)
    plt.axis('equal')
    
    # Save the plot
    plot_path = os.path.join(output_dir, 'first_layer_analysis.png')
    plt.savefig(plot_path, dpi=300, bbox_inches='tight')
    print(f"[ANALYSIS] Visualization saved to: {plot_path}")
    
    return plot_path


def calculate_hull_metrics(hull_points):
    """Calculate useful metrics about the convex hull."""
    print("[MEASURE] Calculating hull metrics...")
    
    # Calculate area using shoelace formula
    area = 0.5 * abs(sum((hull_points[i, 0] * hull_points[(i+1) % len(hull_points), 1] - 
                         hull_points[(i+1) % len(hull_points), 0] * hull_points[i, 1]) 
                        for i in range(len(hull_points))))
    
    # Calculate perimeter
    perimeter = sum(np.linalg.norm(hull_points[(i+1) % len(hull_points)] - hull_points[i]) 
                   for i in range(len(hull_points)))
    
    # Calculate bounding box
    min_x, min_y = np.min(hull_points, axis=0)
    max_x, max_y = np.max(hull_points, axis=0)
    width = max_x - min_x
    height = max_y - min_y
    
    # Calculate center
    center_x = (min_x + max_x) / 2
    center_y = (min_y + max_y) / 2
    
    metrics = {
        'area': area,
        'perimeter': perimeter,
        'width': width,
        'height': height,
        'center': (center_x, center_y),
        'num_vertices': len(hull_points)
    }
    
    print(f"[MEASURE] Hull metrics:")
    print(f"   Area: {area:.2f} mmÂ²")
    print(f"   Perimeter: {perimeter:.2f} mm")
    print(f"   Dimensions: {width:.2f} x {height:.2f} mm")
    print(f"   Center: ({center_x:.2f}, {center_y:.2f})")
    print(f"   Vertices: {len(hull_points)}")
    
    return metrics


def main():
    parser = argparse.ArgumentParser(description='Extract gcode from .gcode.3mf and analyze first layer')
    parser.add_argument('input_file', help='Path to the .gcode.3mf file or STL file')
    parser.add_argument('--no-viz', action='store_true',
                       help='Skip visualization generation')
    
    args = parser.parse_args()
    
    input_file = os.path.abspath(args.input_file)
    output_dir = os.path.dirname(input_file)
    
    try:
        # Step 1: Determine if input is .gcode.3mf or STL
        if input_file.endswith('.gcode.3mf'):
            gcode_3mf_path = input_file
            print(f"[FILE] Using provided G-code 3MF file: {gcode_3mf_path}")
        else:
            # Find the .gcode.3mf file based on STL path
            gcode_3mf_path = find_gcode_3mf_file(input_file)
        
        # Step 2: Extract gcode using ReplaceBaseplate method
        gcode_content = extract_gcode_from_3mf_file(gcode_3mf_path)
        
        # Step 3: Parse first layer
        first_layer_points = parse_gcode_first_layer(gcode_content)
        
        # Step 4: Compute convex hull
        hull, hull_points = compute_convex_hull(first_layer_points)
        
        # Step 5: Calculate metrics
        metrics = calculate_hull_metrics(hull_points)
        
        # Step 6: Create visualization (unless skipped)
        if not args.no_viz:
            plot_path = visualize_results(first_layer_points, hull_points, output_dir)
        
        print("\n[OK] Analysis completed successfully!")
        print(f"[FILE] Results saved in: {output_dir}")
        
        return metrics
        
    except Exception as e:
        print(f"[ERROR] Error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()